#@key_label   "name"
#@meta_label  "type"

# ####################################################
# [name="flreconstruct" type="flreconstruct::section"]

###################################################################
[name="flreconstruct.variantService" type="flreconstruct::section"]
profile : string as path = "simu.profile"

#############################################################
[name="flreconstruct.services" type="flreconstruct::section"]
config : string = "services.conf"

############################################################
[name="flreconstruct.plugins" type="flreconstruct::section"]
plugins : string[1] = "Falaise_SimRC"

##########################################
[name="pipeline" type="dpp::chain_module"]
# The reconstruction pipeline must start with the SimRC module, followed by
# usual reconstruction modules
modules : string[1] = "SimRC"
   
#####################################################
[name="SimRC" type="snemo::simulation::simrc_module"]
  #@config A module which applies 'Running Conditions' to idealized truth MC events
  logging.priority : string = "debug"
  # EH_label         : string = "EH"
  # SD_label         : string = "SD"

  # Step 1: add a decay timestamp in each event header, using a specific
  # time distribution of decay activity and a list of runs to be emulated:
  timestamp_event  : boolean = true
    # Specific configuration of the event timestamper:
    event_timestamper.debug : boolean = true
    event_timestamper.mc_event_timestamps_file : string as path = "mc_event_timestamps.lis"
    # event_timestamper.run_lists : string[1] = "runs.lis"
    # event_timestamper.activity_model_factory.config : string as path = "activity_model_factory.conf"
    # event_timestamper.activity_model : string = "constant_1mBq"
    # event_timestamper.run_statistics.time_step : string = "00:15:00" # 15 minutes

    # We have 100 events to be timestamped from flsimulate:
    event_timestamper.number_of_events : integer = 100
    # As we have 100 precomputed sampled timestamps from the file,
    # we need to use each of them 1 time:
    event_timestamper.timestamp_reuse_factor : integer = 1

  # Step 2: use the decay timestamp found in the event header, and tag truth tracker cells
  # with a special status (dead, off...) to be taken into account at digitization step
  # (some tracker calibrated hits won't be generated at all, or will be incomplete)
  tag_tracker_cell : boolean = false
    # Specific configuration of the tracker cell tagger:
    tracker_cell_tagger.debug : boolean = true
    
  # Step 3: use the decay timestamp found in the event header, and tag truth calorimeter
  # OMs cells with a special status (dead, off...) to be taken into account at
  # digitization step (some calorimeter calibrated hits won't be generated at all)
  tag_calorimeter_om : boolean = false
    # Specific configuration of the calorimeter optical module tagger:
    calorimeter_om_tagger.debug : boolean = true

# end


