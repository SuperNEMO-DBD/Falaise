//  falaise/app/metadata_utils.cc

// Ourselves
#include "falaise/app/metadata_utils.h"

// Third party:
// - Bayeux:
#include <bayeux/datatools/kernel.h>
#include <bayeux/datatools/urn_query_service.h>
#include <bayeux/dpp/input_module.h>

namespace falaise {

  namespace app {

    void metadata_input::reset()
    {
      userProfile = "";
      experimentalSetupUrn = "";
      numberOfEvents = 0;
      doSimulation = false;
      simuSetupUrn = "";
      doDigitization = false;
      digiSetupUrn = "";
      doReconstruction = false;
      recSetupUrn = "";
      return;
    }

    void metadata_input::print(std::ostream & out_) const
    {
      static const std::string tag("|-- ");
      static const std::string last_tag("`-- ");
      out_ << "Input metadata of interest: " << std::endl;
      out_ << tag
           << "userProfile           = " << userProfile << std::endl;
      out_ << tag
           << "experimentalSetupUrn  = " << experimentalSetupUrn << std::endl;
      out_ << tag
           << "numberOfEvents        = " << numberOfEvents << std::endl;
      out_ << tag
           << "doSimulation          = " << std::boolalpha << doSimulation << std::endl;
      out_ << tag
           << "simuSetupUrn          = " << simuSetupUrn << std::endl;
      out_ << tag
           << "doDigitization        = " << std::boolalpha << doDigitization << std::endl;
      out_ << tag
           << "digiSetupUrn          = " << digiSetupUrn << std::endl;
      out_ << tag
           << "doReconstruction      = " << std::boolalpha << doReconstruction << std::endl;
      out_ << last_tag
           << "recSetupUrn           = " << recSetupUrn << std::endl;
      return;
    }

    void metadata_input::scan(const datatools::multi_properties & mp_)
    {
      datatools::logger::priority logging = datatools::logger::PRIO_FATAL;
      datatools::kernel & dtk = datatools::kernel::instance();
      const datatools::urn_query_service & dtkUrnQuery = dtk.get_urn_query();
      if (mp_.empty()) {
        return;
      }
      metadata_scanner ms(mp_);

      // Input metadata from FLSimulate
      if (ms.check_section("flsimulate", "flsimulate::section")) {
        // DT_LOG_DEBUG(logging, "Input metadata were generated by FLSimulate");
        ms.find_string ("flsimulate", "flsimulate::section", "userProfile",          this->userProfile);
        ms.find_string ("flsimulate", "flsimulate::section", "experimentalSetupUrn", this->experimentalSetupUrn);
        ms.find_size   ("flsimulate", "flsimulate::section", "numberOfEvents",       this->numberOfEvents);
        ms.find_boolean("flsimulate", "flsimulate::section", "doSimulation",         this->doSimulation);
        ms.find_boolean("flsimulate", "flsimulate::section", "doDigitization",       this->doDigitization);

        // Simulation section:
        if (this->doSimulation && ms.check_section("flsimulate.simulation", "flsimulate::section")) {
          ms.find_string("flsimulate.simulation", "flsimulate::section", "simulationSetupUrn", this->simuSetupUrn);
        }

        // Digitization section:
        if (this->doDigitization && ms.check_section("flsimulate.digitization", "flsimulate::section")) {
          ms.find_string("flsimulate.digitization", "flsimulate::section", "digitizationSetupUrn", this->digiSetupUrn);
        }

        // If no experimental setup identifier/URN is set:
        if (this->experimentalSetupUrn.empty() && !this->simuSetupUrn.empty()) {
          // Then try to fetch the simulation setup identifier/URN:
          std::string conf_category = "simsetup";
          DT_THROW_IF(!dtkUrnQuery.check_urn_info(this->simuSetupUrn, conf_category),
                      std::logic_error,
                      "Cannot query URN='" << this->simuSetupUrn << "'!");
          // and extract the associated 'experimentalSetupUrn':
          const datatools::urn_info & simuSetupUrnInfo = dtkUrnQuery.get_urn_info(this->simuSetupUrn);
          if (simuSetupUrnInfo.has_topic("expsetup") &&
              simuSetupUrnInfo.get_components_by_topic("expsetup").size() == 1) {
            this->experimentalSetupUrn = simuSetupUrnInfo.get_component("expsetup");
          }
        }
        if (this->experimentalSetupUrn.empty() && !this->digiSetupUrn.empty()) {
          // Then try to fetch the digitization setup identifier/URN:
          std::string conf_category = "digisetup";
          DT_THROW_IF(!dtkUrnQuery.check_urn_info(this->digiSetupUrn, conf_category),
                      std::logic_error,
                      "Cannot query URN='" << this->digiSetupUrn << "'!");
          // and extract the associated 'experimentalSetupUrn':
          const datatools::urn_info & digiSetupUrnInfo = dtkUrnQuery.get_urn_info(this->digiSetupUrn);
          if (digiSetupUrnInfo.has_topic("expsetup") &&
              digiSetupUrnInfo.get_components_by_topic("expsetup").size() == 1) {
            this->experimentalSetupUrn = digiSetupUrnInfo.get_component("expsetup");
          }
        }

      } // Input metadata from FLSimulate

      // Input metadata from FLReconstruct
      if (ms.check_section("flreconstruct", "flreconstruct::section")) {
        this->doReconstruction = true;
        // DT_LOG_DEBUG(logging, "Input metadata were generated by FLReconstruct");
        ms.find_string("flreconstruct", "flreconstruct::section", "userProfile",          this->userProfile);
        ms.find_string("flreconstruct", "flreconstruct::section", "experimentalSetupUrn", this->experimentalSetupUrn);
        ms.find_size  ("flreconstruct", "flreconstruct::section", "numberOfEvents",       this->numberOfEvents);

        // Reconstruction section:
        if (this->doReconstruction && ms.check_section("flreconstruct.pipeline", "flreconstruct::section")) {
          ms.find_string("flreconstruct.pipeline", "flreconstruct::section", "configUrn", this->recSetupUrn);
        }

        // If no experimental setup identifier/URN is set:
        if (this->experimentalSetupUrn.empty() && !this->recSetupUrn.empty()) {
          // Then try to fetch the reconstruction setup identifier/URN:
          std::string conf_category = "recsetup";
          DT_THROW_IF(!dtkUrnQuery.check_urn_info(this->recSetupUrn, conf_category),
                      std::logic_error,
                      "Cannot query URN='" << this->recSetupUrn << "'!");
          // and extract the associated 'experimentalSetupUrn':
          const datatools::urn_info & recSetupUrnInfo = dtkUrnQuery.get_urn_info(this->recSetupUrn);
          if (recSetupUrnInfo.has_topic("expsetup") &&
              recSetupUrnInfo.get_components_by_topic("expsetup").size() == 1) {
            this->experimentalSetupUrn = recSetupUrnInfo.get_component("expsetup");
          }
        }

      } // Input metadata from FLReconstruct

      return;
    }

    metadata_collector::metadata_collector(const uint32_t flags_)
      : _flags_(flags_)
    {
      return;
    }

    void metadata_collector::set_input_data_file(const std::string & idf_)
    {
      _input_data_file_ = idf_;
      return;
    }

    void metadata_collector::set_input_metadata_file(const std::string & imf_)
    {
      _input_metadata_file_ = imf_;
      return;
    }

    datatools::multi_properties
    metadata_collector::get_metadata_from_data_file() const
    {
      // Metadata is currently available as soon as the input module is initialized.
      std::unique_ptr<dpp::input_module> inputMod(new dpp::input_module);
      std::string dfile(_input_data_file_);
      datatools::fetch_path_with_env(dfile);
      inputMod->set_single_input_file(dfile);
      // Input metadata management:
      const datatools::multi_properties& iMetadataStore = inputMod->get_metadata_store();
      inputMod->initialize_simple();
      datatools::multi_properties md;
      md.clear_key_label();
      md.clear_meta_label();
      md = iMetadataStore;
      md.set_meta_label("type");
      return md;
    }

    datatools::multi_properties
    metadata_collector::get_metadata_from_metadata_file() const
    {
      std::string mdfile = _input_metadata_file_;
      datatools::fetch_path_with_env(mdfile);
      datatools::multi_properties md;
      md.clear_key_label();
      md.clear_meta_label();
      md.read(mdfile);
      return md;
    }

    datatools::multi_properties
    metadata_collector::get_metadata() const
    {
      datatools::multi_properties md;
      return md;
    }

    metadata_scanner::metadata_scanner(const datatools::multi_properties & mp_)
      : _mp_(mp_)
    {
      return;
    }

    bool metadata_scanner::_find_data_in_section_(const std::string & section_name_,
                                                  const std::string & section_type_,
                                                  const std::string & propKey_,
                                                  datatools::properties::data & data_) const
    {
      if (!check_section(section_name_, section_type_)) {
        return false;
      }
      const datatools::properties & aSection = _mp_.get_section(section_name_);
      if (!aSection.has_key(propKey_)) {
        return false;
      }
      data_ = aSection.get(propKey_);
      return true;
    }

    bool metadata_scanner::check_section(const std::string & section_name_,
                                         const std::string & section_type_) const
    {
      if (_mp_.empty()) return false;
      if (!_mp_.has_key_with_meta(section_name_, section_type_)) {
        return false;
      }
      return true;
    }

    const datatools::properties &
    metadata_scanner::get_section(const std::string & section_name_,
                                  const std::string & section_type_) const
    {
      return _mp_.get_section(section_name_);
    }

    bool metadata_scanner::find_boolean(const std::string & section_name_,
                                        const std::string & section_type_,
                                        const std::string & propKey_,
                                        bool & propValue_) const
    {
      datatools::properties::data d;
      if (!_find_data_in_section_(section_name_, section_type_, propKey_, d)) {
        return false;
      }
      if (!d.is_boolean()) return false;
      propValue_ = d.get_boolean_value();
      return true;
    }

    bool metadata_scanner::find_path(const std::string & section_name_,
                                     const std::string & section_type_,
                                     const std::string & propKey_,
                                     std::string & propValue_) const
    {
      datatools::properties::data d;
      if (!_find_data_in_section_(section_name_, section_type_, propKey_, d)) {
        return false;
      }
      if (!d.is_path()) return false;
      propValue_ = d.get_string_value();
      return true;
    }

    bool metadata_scanner::find_string(const std::string & section_name_,
                                       const std::string & section_type_,
                                       const std::string & propKey_,
                                       std::string & propValue_) const
    {
      datatools::properties::data d;
      if (!_find_data_in_section_(section_name_, section_type_, propKey_, d)) {
        return false;
      }
      if (!d.is_string()) return false;
      propValue_ = d.get_string_value();
      return true;
    }

    bool metadata_scanner::find_size(const std::string & section_name_,
                                     const std::string & section_type_,
                                     const std::string & propKey_,
                                     std::size_t & propValue_) const
    {
      datatools::properties::data d;
      if (!_find_data_in_section_(section_name_, section_type_, propKey_, d)) {
        return false;
      }
      if (!d.is_integer()) return false;
      propValue_ = (std::size_t) d.get_integer_value();
      return true;
    }

    bool metadata_scanner::find_integer(const std::string & section_name_,
                                        const std::string & section_type_,
                                        const std::string & propKey_,
                                        int & propValue_) const
    {
      datatools::properties::data d;
      if (!_find_data_in_section_(section_name_, section_type_, propKey_, d)) {
        return false;
      }
      if (!d.is_integer()) return false;
      propValue_ = d.get_integer_value();
      return true;
    }

    bool metadata_scanner::find_real(const std::string & section_name_,
                                        const std::string & section_type_,
                                        const std::string & propKey_,
                                        double & propValue_) const
    {
      datatools::properties::data d;
      if (!_find_data_in_section_(section_name_, section_type_, propKey_, d)) {
        return false;
      }
      if (!d.is_real()) return false;
      propValue_ = d.get_real_value();
      return true;
    }

  } // namespace app

} // namespace falaise
