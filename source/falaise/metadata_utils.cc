//  falaise/app/metadata_utils.cc

// Ourselves
#include "falaise/metadata_utils.h"

// Third party:
// - Bayeux:
#include <bayeux/datatools/kernel.h>
#include <bayeux/datatools/urn_query_service.h>
#include <bayeux/dpp/input_module.h>

namespace falaise {

namespace app {
void metadata_collector::set_input_data_file(const std::string& filename) { brioFile_ = filename; }

void metadata_collector::set_input_metadata_file(const std::string& filename) {
  textFile_ = filename;
}

datatools::multi_properties metadata_collector::get_metadata_from_data_file() const {
  // Metadata is currently available as soon as the input module is initialized.
  std::unique_ptr<dpp::input_module> inputMod(new dpp::input_module);
  std::string dfile(brioFile_);
  datatools::fetch_path_with_env(dfile);
  inputMod->set_single_input_file(dfile);
  // Input metadata management:
  const datatools::multi_properties& iMetadataStore = inputMod->get_metadata_store();
  inputMod->initialize_simple();
  datatools::multi_properties md;
  md.clear_key_label();
  md.clear_meta_label();
  md = iMetadataStore;
  return md;
}

datatools::multi_properties metadata_collector::get_metadata_from_metadata_file() const {
  std::string mdfile = textFile_;
  datatools::fetch_path_with_env(mdfile);
  datatools::multi_properties md;
  md.clear_key_label();
  md.clear_meta_label();
  md.read(mdfile);
  return md;
}

// ----- metadata_input

void metadata_input::print(std::ostream& os) const {
  static const std::string tag("|-- ");
  static const std::string last_tag("`-- ");
  os << tag << "userProfile           = '" << userProfile << "'" << std::endl;
  os << tag << "experimentalSetupUrn  = '" << experimentalSetupUrn << "'" << std::endl;
  os << tag << "variantConfigUrn      = '" << variantConfigUrn << "'" << std::endl;
  os << tag << "variantConfigPath     = '" << variantConfigPath << "'" << std::endl;
  os << tag << "variantProfileUrn     = '" << variantProfileUrn << "'" << std::endl;
  os << tag << "variantProfilePath    = '" << variantProfilePath << "'" << std::endl;
  os << tag << "servicesConfigUrn     = '" << servicesConfigUrn << "'" << std::endl;
  os << tag << "servicesConfigPath    = '" << servicesConfigPath << "'" << std::endl;
  os << tag << "numberOfEvents        = " << numberOfEvents << std::endl;
  os << tag << "doSimulation          = " << std::boolalpha << doSimulation << std::endl;
  os << tag << "simuSetupUrn          = '" << simuSetupUrn << "'" << std::endl;
  os << tag << "doDigitization        = " << std::boolalpha << doDigitization << std::endl;
  os << tag << "digiSetupUrn          = '" << digiSetupUrn << "'" << std::endl;
  os << tag << "doReconstruction      = " << std::boolalpha << doReconstruction << std::endl;
  os << last_tag << "recSetupUrn           = '" << recSetupUrn << "'" << std::endl;
}

void metadata_input::scan(const datatools::multi_properties& mp) {
  datatools::kernel& dtk = datatools::kernel::instance();
  const datatools::urn_query_service& dtkUrnQuery = dtk.get_urn_query();
  if (mp.empty()) {
    return;
  }
  metadata_scanner ms(mp);

  // Input metadata from FLSimulate
  if (ms.hasSection("flsimulate", "flsimulate::section")) {
    // DT_LOG_DEBUG(logging, "Input metadata were generated by FLSimulate");
    ms.getString("flsimulate", "flsimulate::section", "userProfile", this->userProfile);
    ms.getString("flsimulate", "flsimulate::section", "experimentalSetupUrn",
                   this->experimentalSetupUrn);
    ms.getSize("flsimulate", "flsimulate::section", "numberOfEvents", this->numberOfEvents);
    ms.getBoolean("flsimulate", "flsimulate::section", "doSimulation", this->doSimulation);
    ms.getBoolean("flsimulate", "flsimulate::section", "doDigitization", this->doDigitization);

    // Simulation section:
    if (this->doSimulation && ms.hasSection("flsimulate.simulation", "flsimulate::section")) {
      ms.getString("flsimulate.simulation", "flsimulate::section", "simulationSetupUrn",
                     this->simuSetupUrn);
    }

    // Digitization section:
    if (this->doDigitization && ms.hasSection("flsimulate.digitization", "flsimulate::section")) {
      ms.getString("flsimulate.digitization", "flsimulate::section", "digitizationSetupUrn",
                     this->digiSetupUrn);
    }

    // If no experimental setup identifier/URN is set:
    if (this->experimentalSetupUrn.empty() && !this->simuSetupUrn.empty()) {
      // Then try to fetch the simulation setup identifier/URN:
      std::string conf_category = "simsetup";
      DT_THROW_IF(!dtkUrnQuery.check_urn_info(this->simuSetupUrn, conf_category), std::logic_error,
                  "Cannot query URN='" << this->simuSetupUrn << "'!");
      // and extract the associated 'experimentalSetupUrn':
      const datatools::urn_info & simuSetupUrnInfo = dtkUrnQuery.get_urn_info(this->simuSetupUrn);
      if (simuSetupUrnInfo.has_topic("setup") &&
          simuSetupUrnInfo.get_components_by_topic("setup").size() == 1) {
        this->experimentalSetupUrn = simuSetupUrnInfo.get_component("setup");
      }
    }
    if (this->experimentalSetupUrn.empty() && !this->digiSetupUrn.empty()) {
      // Then try to fetch the digitization setup identifier/URN:
      std::string conf_category = "digisetup";
      DT_THROW_IF(!dtkUrnQuery.check_urn_info(this->digiSetupUrn, conf_category), std::logic_error,
                  "Cannot query URN='" << this->digiSetupUrn << "'!");
      // and extract the associated 'experimentalSetupUrn':
      const datatools::urn_info & digiSetupUrnInfo = dtkUrnQuery.get_urn_info(this->digiSetupUrn);
      if (digiSetupUrnInfo.has_topic("setup") &&
          digiSetupUrnInfo.get_components_by_topic("setup").size() == 1) {
        this->experimentalSetupUrn = digiSetupUrnInfo.get_component("setup");
      }
    }

  }  // Input metadata from FLSimulate

  // Input metadata from FLReconstruct
  if (ms.hasSection("flreconstruct", "flreconstruct::section")) {
    this->doReconstruction = true;
    ms.getString("flreconstruct", "flreconstruct::section", "userProfile", this->userProfile);
    ms.getString("flreconstruct", "flreconstruct::section", "reconstructionSetupUrn",
                   this->recSetupUrn);
    ms.getString("flreconstruct", "flreconstruct::section", "experimentalSetupUrn",
                   this->experimentalSetupUrn);
    ms.getSize("flreconstruct", "flreconstruct::section", "numberOfEvents", this->numberOfEvents);

    // // Reconstruction section:
    // if (this->doReconstruction &&
    //     ms.hasSection("flreconstruct.pipeline", "flreconstruct::section")) {
    //   ms.getString("flreconstruct.pipeline", "flreconstruct::section", "configUrn",
    //                  this->recSetupUrn);
    // }

    // If no experimental setup identifier/URN is set:
    if (this->experimentalSetupUrn.empty() && !this->recSetupUrn.empty()) {
      // Then try to fetch the reconstruction setup identifier/URN:
      std::string conf_category = "recsetup";
      DT_THROW_IF(!dtkUrnQuery.check_urn_info(this->recSetupUrn, conf_category), std::logic_error,
                  "Cannot query URN='" << this->recSetupUrn << "'!");
      // and extract the associated 'experimentalSetupUrn':
      const datatools::urn_info & recSetupUrnInfo = dtkUrnQuery.get_urn_info(this->recSetupUrn);
      if (recSetupUrnInfo.has_topic("setup") &&
          recSetupUrnInfo.get_components_by_topic("setup").size() == 1) {
        this->experimentalSetupUrn = recSetupUrnInfo.get_component("setup");
      }
    }

  }  // Input metadata from FLReconstruct
}

// ----- metadata_scanner

metadata_scanner::metadata_scanner(const datatools::multi_properties& mp) : metadata_(mp) {}

bool metadata_scanner::hasSection(const std::string& name, const std::string& type) const {
  if (metadata_.empty()) {
    return false;
  }
  if (!metadata_.has_key_with_meta(name, type)) {
    return false;
  }
  return true;
}

const datatools::properties& metadata_scanner::getSection(const std::string& name,
                                                          const std::string& /*type*/) const {
  return metadata_.get_section(name);
}

bool metadata_scanner::getBoolean(const std::string& name, const std::string& type,
                                  const std::string& key, bool& value) const {
  datatools::properties::data d;
  if (!getDataFromSection(name, type, key, d)) {
    return false;
  }
  if (!d.is_boolean()) {
    return false;
  }
  value = d.get_boolean_value();
  return true;
}

bool metadata_scanner::getPath(const std::string& name, const std::string& type,
                               const std::string& key, std::string& value) const {
  datatools::properties::data d;
  if (!getDataFromSection(name, type, key, d)) {
    return false;
  }
  if (!d.is_path()) {
    return false;
  }
  value = d.get_string_value();
  return true;
}

bool metadata_scanner::getString(const std::string& name, const std::string& type,
                                 const std::string& key, std::string& value) const {
  datatools::properties::data d;
  if (!getDataFromSection(name, type, key, d)) {
    return false;
  }
  if (!d.is_string()) {
    return false;
  }
  value = d.get_string_value();
  return true;
}

bool metadata_scanner::getSize(const std::string& name, const std::string& type,
                               const std::string& key, std::size_t& value) const {
  datatools::properties::data d;
  if (!getDataFromSection(name, type, key, d)) {
    return false;
  }
  if (!d.is_integer()) {
    return false;
  }
  value = (std::size_t)d.get_integer_value();
  return true;
}

bool metadata_scanner::getInteger(const std::string& name, const std::string& type,
                                  const std::string& key, int& value) const {
  datatools::properties::data d;
  if (!getDataFromSection(name, type, key, d)) {
    return false;
  }
  if (!d.is_integer()) {
    return false;
  }
  value = d.get_integer_value();
  return true;
}

bool metadata_scanner::getReal(const std::string& name, const std::string& type,
                               const std::string& key, double& value) const {
  datatools::properties::data d;
  if (!getDataFromSection(name, type, key, d)) {
    return false;
  }
  if (!d.is_real()) {
    return false;
  }
  value = d.get_real_value();
  return true;
}

bool metadata_scanner::getDataFromSection(const std::string& name, const std::string& type,
                                          const std::string& key,
                                          datatools::properties::data& value) const {
  if (!hasSection(name, type)) {
    return false;
  }
  const datatools::properties& aSection = getSection(name, type);
  if (!aSection.has_key(key)) {
    return false;
  }
  value = aSection.get(key);
  return true;
}

}  // namespace app

}  // namespace falaise
